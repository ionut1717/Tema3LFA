# Context-Free Grammar (CFG) Handler

This project provides a Python implementation for defining, verifying, and manipulating Context-Free Grammars (CFGs). It allows you to define a grammar, generate strings from it, find leftmost derivations for specific strings, and recognize whether a string belongs to the language defined by the grammar.

## Description

The core of this project is the `CFG` class, which encapsulates the components of a Context-Free Grammar: non-terminal symbols, terminal symbols, production rules, and a start symbol. The accompanying script reads instructions from an `input.txt` file to perform various operations on defined CFGs, such as verification, string generation, and string recognition.

## Features

* **CFG Definition & Verification**: Define a CFG and perform checks to ensure its validity (e.g., disjoint terminals/non-terminals, valid symbols in production rules).

* **CFG Printing**: Display the grammar's components in a clear, human-readable format.

* **String Generation**: Generate random strings that conform to the grammar's rules, up to a specified maximum length. This uses a recursive approach with safeguards against infinite loops.

* **Leftmost Derivation**: Compute and display the leftmost derivation steps for a given target string. This helps visualize how a string can be generated from the start symbol.

* **String Recognition**: Determine if a given string can be generated by the grammar by attempting to find its leftmost derivation.

## How to Use

The program operates by reading commands and CFG definitions from an `input.txt` file. Each task is identified by a `taskN` header.

### `input.txt` Format

The `input.txt` file should contain one or more tasks. Each task starts with `taskX` (where X is the task number) and ends with `END`.

#### Task 1: Define and Verify CFG

This task defines a new CFG and verifies its correctness. If valid, it becomes the `working_CFG` for subsequent tasks.
Markdown

# Context-Free Grammar (CFG) Handler

This project provides a Python implementation for defining, verifying, and manipulating Context-Free Grammars (CFGs). It allows you to define a grammar, generate strings from it, find leftmost derivations for specific strings, and recognize whether a string belongs to the language defined by the grammar.

## Description

The core of this project is the `CFG` class, which encapsulates the components of a Context-Free Grammar: non-terminal symbols, terminal symbols, production rules, and a start symbol. The accompanying script reads instructions from an `input.txt` file to perform various operations on defined CFGs, such as verification, string generation, and string recognition.

## Features

* **CFG Definition & Verification**: Define a CFG and perform checks to ensure its validity (e.g., disjoint terminals/non-terminals, valid symbols in production rules).

* **CFG Printing**: Display the grammar's components in a clear, human-readable format.

* **String Generation**: Generate random strings that conform to the grammar's rules, up to a specified maximum length. This uses a recursive approach with safeguards against infinite loops.

* **Leftmost Derivation**: Compute and display the leftmost derivation steps for a given target string. This helps visualize how a string can be generated from the start symbol.

* **String Recognition**: Determine if a given string can be generated by the grammar by attempting to find its leftmost derivation.

## How to Use

The program operates by reading commands and CFG definitions from an `input.txt` file. Each task is identified by a `taskN` header.

### `input.txt` Format

The `input.txt` file should contain one or more tasks. Each task starts with `taskX` (where X is the task number) and ends with `END`.

#### Task 1: Define and Verify CFG

This task defines a new CFG and verifies its correctness. If valid, it becomes the `working_CFG` for subsequent tasks.

task1
NON_TERMINALS: S, A, B
TERMINALS: a, b, c
START_SYMBOL: S
PRODUCTION_RULES:
S -> aA | bB
A -> aA | c
B -> bB | c
END_PRODUCTION_RULES
END

* `NON_TERMINALS`: Comma-separated list of non-terminal symbols.

* `TERMINALS`: Comma-separated list of terminal symbols.

* `START_SYMBOL`: The starting non-terminal symbol for derivations.

* `PRODUCTION_RULES`: Followed by lines defining rules in the format `LHS -> RHS1 | RHS2 | ...`. Use `Îµ` for an empty string production, but represent it as an empty string `""` in the production rules within the code.

* `END_PRODUCTION_RULES`: Marks the end of production rules for the current CFG.

* `END`: Marks the end of `task1`.

#### Task 2: Generate Strings

Generates a specified number of strings from the current `working_CFG`, up to a given maximum length.

task2
3  // Number of strings to generate (max 10)
8  // Maximum length of generated strings (max 10)
END

#### Task 3: Find Leftmost Derivation

Attempts to find and print the leftmost derivation for a `target_string` using the `working_CFG`.

task3
aaac // Target string
END
#### Task 4: Recognize Strings

Checks if a list of `target_string`s can be recognized by the `working_CFG` (i.e., if a leftmost derivation exists). Prints `True` or `False` for each.

task4
2 // Number of strings to recognize
aaac
bbbc
END

#### Task 5: Bonus CFG Example

This task demonstrates a predefined bonus CFG, prints its details, generates a string, and attempts to recognize a specific string.

task5
END

## Class Structure (`CFG` class)

### `__init__(self, non_terminals, terminals, production_rules, start_symbol)`

* **Parameters**:

    * `non_terminals` (list): A list of strings representing non-terminal symbols.

    * `terminals` (list): A list of strings representing terminal symbols.

    * `production_rules` (dict): A dictionary where keys are non-terminal symbols (strings) and values are lists of strings representing their production rules' right-hand sides. Use `""` for epsilon ($\varepsilon$) productions.

    * `start_symbol` (str): The starting non-terminal symbol.

* **Description**: Initializes the CFG object, converting non-terminals and terminals to sets for efficient lookup. It also pre-sorts these symbols by length (descending) for correct parsing in `verify_string` and `generate_string`.

### `verify_CFG(self)`

* **Returns**: `bool`

* **Description**: Checks the validity of the CFG definition.

    * Ensures all components are provided.

    * Verifies the start symbol is a non-terminal.

    * Confirms non-terminals and terminals are disjoint.

    * Checks if all symbols in production rules are valid (either a non-terminal or a terminal).

    * Prints error messages if any validation fails.

### `verify_string(self, string)`

* **Parameters**:

    * `string` (str): The string to verify.

* **Returns**: `bool`

* **Description**: Helper method to check if a given string (typically a right-hand side of a production rule) consists only of valid terminal and non-terminal symbols defined in the CFG. It parses the string from left to right, matching the longest possible symbol first.

### `print_CFG(self)`

* **Description**: Prints the non-terminals, terminals, start symbol, and production rules in a formatted way. Epsilon ($\varepsilon$) productions are displayed correctly.

### `generate_string(self, max_length=10)`

* **Parameters**:

    * `max_length` (int, optional): The maximum length of the terminal string to generate. Defaults to 10.

* **Returns**: `str` or `None`

* **Description**: Attempts to randomly generate a string belonging to the language defined by the CFG. It uses a recursive, leftmost derivation approach. It includes safeguards (`max_depth` and `max_tries`) to prevent infinite recursion and ensure termination. Returns `None` if a string within the `max_length` cannot be generated after `max_tries`.

### `leftmost_deviation(self, target_string, max_recursion_depth=200)`

* **Parameters**:

    * `target_string` (str): The string for which to find the leftmost derivation.

    * `max_recursion_depth` (int, optional): The maximum depth for the recursive derivation search. Defaults to 200.

* **Returns**: `str`

* **Description**: Finds the leftmost derivation for a given `target_string`. It recursively explores possible derivations, always expanding the leftmost non-terminal. Returns a string representing the derivation steps (e.g., `S=>aA=>aaB`) or a message indicating no derivation was found. Handles epsilon ($\varepsilon$) productions correctly.

### `recognize_string(self, target_string, max_recursion_depth=2000)`

* **Parameters**:

    * `target_string` (str): The string to recognize.

    * `max_recursion_depth` (int, optional): The maximum depth for the internal derivation search. Defaults to 2000.

* **Description**: Determines if the `target_string` can be generated by the CFG. It internally calls `leftmost_deviation` and prints `True` if a derivation is found, `False` otherwise.

## Dependencies

* `random`: For random selection of production rules during string generation.

* `collections.defaultdict`: For easily handling production rules where a non-terminal might not yet have any rules defined.

* `re`: For regular expression matching in the input file parsing.